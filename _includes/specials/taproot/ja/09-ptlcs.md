[先週のコラムでは][p4tr sig adaptors]、[署名アダプター][topic adaptor signatures]と
[Schnorr署名][topic schnorr signatures]をサポートする[Taproot][topic taproot]のアクティベーションにより、
アダプターを非公開で効率的に使用することが簡単になることを紹介しました。
署名アダプターをBitcoinで使用する方法はいくつかありますが、最もすぐに役立つものの１つは、
長年使用されてきた[歴史ある][htlc history]Hash Time Locked Contracts ([HTLC][topic htlc])に代わる
Point Time Locked Contracts ([PTLC][topic ptlc])です。
これにはいくつかの利点がありますが、同時にいくつかの課題もあります。
両方を理解するために、まず現在使用されているHTLCの簡単な例から説明します。
以下の例では、オフチェーンのLN支払い、オンチェーンのcoinswap、
Lightning Loopのようなオンチェーン/オフチェーンのハイブリッドシステムが考えられます。
この柔軟性により、HTLCは広く利用されています。

アリスは、アリスもキャロルも信頼をしないボブを経由して支払いをルーティングすることで、キャロルに支払いをしたいと考えています。
キャロルはランダムなプリイメージを作成し、SHA256アルゴリズムでハッシュします。
キャロルはそのハッシュをアリスに渡し、プリイメージは秘密にしておきます。
アリスは、ボブへの支払いを開始し、ボブは自身の公開鍵に対する署名とプリイメージを使って支払いを受け取れます。
または、アリスは10ブロック経過したら自分の公開鍵に対する署名を使ってトランザクションを自分自身に戻すことで払い戻しをすることが可能です。
この[ポリシー][htlc1 minsc]をMinsc言語で定義すると以下のようになります:

```hack
(pk($bob) && sha256($preimage)) || (pk($alice) && older(10))
```

ボブは、参加者が[更新され][htlc2 minsc]払い戻しのタイムアウトが小さくなるものの基本的に同じScriptを使って、
キャロルに同じ金額（おそらく手数料を差し引いた金額）の支払いを開始することができます。

```hack
(pk($carol) && sha256($preimage)) || (pk($bob) && older(5))
```

これでキャロルは、プリイメージを使って5ブロック以内にボブからの支払いを受け取ることができ、
これによりプリイメージが明らかになり、ボブは同じく5ブロック以内にアリスからの支払いを受け取ることができます。

### HTLCのプライバシーの問題

上記のScriptがオンチェーンで公開された場合、同じハッシュとプリイメージが再利用されていることで、
AがBを経由してCに支払ったことが一目瞭然になります。
これは同じチェーンおよびクロスチェーンのcoinswapにとって重要な問題となります。
あまり明白ではありませんが、これはLNのようなオフチェーンのルーティングプロトコルにとっても問題です。
ある人が経路上の複数のホップを管理している長いルーティング経路を想像すると、
同じハッシュとプリイメージが再利用されていることを確認し、
一部のノードがルーティングノードであることを判断し、残りのノードが送信者か受信者のどちらかである確率を高めることができます。
これはLNの現在のプライバシー上の弱点である*リンク可能性問題*の１つです。

![Illustration of HTLC linkability problem](/img/posts/2021-07-ln-linkability1.dot.png)

[マルチパス支払い][topic multipath payments]は、LNのリンク可能性問題の他の側面（支払い額のリンク可能性など）を部分的に軽減しますが、
監視ルーティングノードにハッシュを相関させる機会を与えることで、ハッシュのリンク可能性問題を悪化させる可能性があります。

現在のHTLCのもう１つの問題は、オンチェーンにする必要のあるScriptが通常の支払いのScriptとは明らかに異なることです。
これにより監視者は使用パターンを特定しやすくなり、おそらく個々のユーザーに特有の情報を効果的に推測することができます。

### PTLCソリューション

これまでのMinscスタイルのScriptでは、事前に選択した特定の値（プリイメージ）が渡された場合にのみtrueを返す関数がありました。
[署名アダプター][topic adaptor signatures]も同様で、関数に公開された値（*スカラー*）が渡された場合のみ、有効な署名に変換することができます。
とりあえず[マルチシグ][topic multisignature]を無視すると、先程のHTLC Scriptは以下のPTLCに変換することができます:

```hack
(pk($bob) && pk($alice_adaptor)) || (pk($alice) && older(10))
```

```hack
(pk($carol) && pk($bob_adaptor)) || (pk($bob) && older(5))
```

つまり、キャロルはアリスに隠されたスカラーに対するEC*ポイント*を渡し、
アリスはそのECポイントと自身が選択した公開鍵を一緒に使用して、ボブに渡す署名アダプターを作成します。
ボブは、自身が選択した公開鍵と同じポイントを使用してキャロルに渡す署名アダプターを作成できます。
キャロルは、ボブのアダプターを有効な署名に変換することでスカラーを公開し、ボブのコインを受け取ります。
ボブは有効な署名からスカラーを復元し、アリスのアダプターを自分の有効な署名に変換し、アリスのコインを受け取ります。

これにより、誰もがブロックチェーンを確認しても個別の公開鍵に対する有効な署名の束があるだけなので、
オンチェーン監視に対するリンク可能性問題が解決されます。
第三者は、アダプターが使用されたことや、そのアダプターがどのスカラーに基づいているかを知ることはできません。

しかし、上記の手順では、ルーティングに参加している監視ノードが支払いをリンクするのを防ぐことはできません。
すべての支払いが同じスカラーに基づいている場合、すべての支払いはハッシュロックとプリイメージを使用した場合と同様リンクされます。
これは、各ルーティングノードが独自のスカラーを選択し、支払いがそのノードを通過する際に対応するポイントを削除することで解決できます。
それでは例を修正してみましょう:

前と同様に、キャロルはアリスに彼女のスカラーに対応するポイントを与えますが、
今回はアリスはボブにもポイントを要求します。アリスは、
キャロルのポイントとボブのポイントの両方を集約したものを使ってボブに渡すアダプターを構築します。
ボブは自分のポイントを知っているので、アリスから受け取ったアダプターからその点を引くことができます。
その結果得られた点（ボブはこれがアリスがキャロルから最初に受け取った点であることを知らない）を使って、
ボブはキャロルに渡すアダプターを構築します。キャロルはその最終的なポイントのスカラーを知っているので、
ボブのアダプターを有効な署名に変換します。前述のように、ボブはキャロルの署名からスカラーを復元し、
それと自分のスカラーを使ってアリスのアダプターを有効な署名に変換します。

この経路の２つのホップ（アリス→ボブとボブ→キャロル）では、２つの異なるECポイントとスカラーが使用されており、
リンク可能性を排除します。これをHTLCで検討した時より長い経路に拡張し、これによりプライバシーがどう改善されるか確認できます:

![Illustration of PTLC lack of linkability problem](/img/posts/2021-07-ln-linkability2.dot.png)

先週述べたように、Schnorr署名を使うとマルチシグのアダプター署名を簡単に構成することができます。
一般的なPTLCの場合、これによりオンチェーンScriptを以下のように削減することができます:

```hack
pk($bob_with_alice_adaptor) || (pk($alice) && older(10))
```

```hack
pk($carol_with_bob_adaptor) || (pk($bob)   && older(5) )
```

Taprootでは、左の分岐がkeypathになり、右の分岐がtapleafになります。
支払いのルーティングが成功すると、ボブとキャロルは相手の協力を得ること無く、
それぞれのパートをオンチェーンで決済することができます。
これにより、このルーティングされた支払いは、シングルシグの支払い、通常のマルチシグの支払い、
協調的に解決されたコントラクトと区別がつきません。また、ブロックスペースの使用を最小限に抑えることができます。
払い戻し条件の１つを実行する場合でも、それはかなり効率的でかなりプライベートなものです---`pk(x) && older(n)`は、
[デグレード・マルチシグ][degrading multisig]や[HODLの強制][enforced hodling]、
その他のさまざまなScriptと区別がつきません。

来週のコラムでは、私たちのお気に入りのLN開発者の１人によるゲスト投稿で、
LNがkeypathによる使用やマルチシグ、PTLCおよびTaprootで可能になるその他の機能を採用するために必要な変更点について説明します。

[p4tr sig adaptors]: /ja/preparing-for-taproot/#署名アダプター
[htlc history]: /en/topics/htlc/#history
[htlc1 minsc]: https://min.sc/#c=%2F%2F%20Traditional%20preimage-based%20HTLC%0A%24alice%20%3D%20A%3B%0A%24bob%20%3D%20B%3B%0A%24carol%20%3D%20C%3B%0A%24preimage%20%3D%20H%3B%0A%0A%28pk%28%24bob%29%20%26%26%20sha256%28%24preimage%29%29%20%7C%7C%20%28pk%28%24alice%29%20%26%26%20older%2810%29%29
[htlc2 minsc]: https://min.sc/#c=%2F%2F%20Traditional%20preimage-based%20HTLC%0A%24alice%20%3D%20A%3B%0A%24bob%20%3D%20B%3B%0A%24carol%20%3D%20C%3B%0A%24preimage%20%3D%20H%3B%0A%0A%28pk%28%24carol%29%20%26%26%20sha256%28%24preimage%29%29%20%7C%7C%20%28pk%28%24bob%29%20%26%26%20older%285%29%29
[degrading multisig]: https://github.com/bitcoinops/taproot-workshop/blob/master/3.1-degrading-multisig-case-study.ipynb
[enforced hodling]: https://bitcoin.stackexchange.com/questions/69809/op-checklocktimeverify-op-hodl-script
