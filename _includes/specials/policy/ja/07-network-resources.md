前回の記事では、ノードリソースの保護について説明しました。
ノードリソースはノード毎に固有であり、設定可能な場合もあります。
また、1つポリシーに収束することが最善である理由についても説明しましたが、
そのポリシーの一部として何が含まれるべきでしょうか？
この記事では、スケーラビリティ、アップグレード性、ブートストラップやフルノードの維持のし易さなどにとって重要な、
ネットワーク全体のリソースの概念について説明します。

[以前の記事][policy01]で説明したように、Bitcoinネットワークの思想的目標の多くは、
その分散構造に具現化されています。Bitcoinのピア・ツー・ピアの性質により、
ネットワークのルールは個々のノードオペレーターの選択の大まかな合意から生まれ、
ネットワーク内で不当な影響力を獲得しようとする試みを抑制します。
これらのルールは、すべてのトランザクションを個別に検証する各ノードによって適用されます。
多様で健全なノード群を実現するには、ノードの運用コストを低く抑える必要があります。
世界中のユーザーを対象にプロジェクトを拡大するのは困難ですが、
分散化を犠牲にすることなくそれを行うことは、片手を背中に縛られて戦うようなものです。
Bitcoinプロジェクトは、共有ネットワークのリソース、つまりUTXOセットや、
ブロックチェーンのデータフットプリントとその処理に必要な計算量、
Bitcoinプロトコルを進化させるためのフックのアップグレードを厳重に保護することで、
このバランスをとろうとしています。

ブロックチェーンの成長に制限を設けることが自分自身のノードを運営するために手頃な価格を維持するのに必要であることを理解するために、
再度ブロックサイズ戦争を繰り返す必要はありません。ただし、ブロックチェーンの成長は、
「[高度に複製された永久的なストレージに対する無制限の需要][unbounded]」の一部を表現するために必要な最小コストを確保する
1 sat/vbyteの`minRelayTxFee`によってポリシーレベルでも抑制されています。

当初、ネットワークの状態は、未使用のアウトプットをまだ持つすべてのトランザクションを保持することで追跡されていました。
ブロックチェーンのこのより大きな部分は、資金を追跡する手段として[UTXOセットの導入][ultraprune]により大幅に削減されました。
それ以来、UTXOセットは中心的なデータ構造となっています。特にIBD中だけでなく一般的にも、
UTXOのルックアップは、ノードのすべてのメモリアクセスの大部分を占めています。
Bitcoin Coreは、既に[UTXOキャッシュ用に手動で最適化されたデータ構造][pooled resource]を使用していますが、
UTXOセットのサイズはノードのキャッシュに収まらない量を決定します。
UTXOセットが大きいほどキャッシュミスが多くなり、ブロックの検証やIBD、トランザクションの検証速度が遅くなります。
ダスト・リミットは、UTXOの作成を制限するポリシーの例であり、
具体的には、その額が支払いに必要なコストを[下回る][topic uneconomical outputs]ため、
決して使用されない可能性のあるUTXOを抑制します。それでも、
[数千件のトランザクションを伴う「ダスト・ストーム」は2020年にも発生しました][lopp storms]。

データをブロックチェーン上に公開するためにベア・マルチシグアウトプットを使用するのが一般的になったとき、
標準トランザクションの定義が修正され、代わりに単一のOP_RETURNアウトプットを許可するようになりました。
人々は、ユーザーがブロックチェーン上にデータを公開するのを防ぐことは不可能であることに気づきましたが、
少なくともそのようなデータは決して使用されないアウトプットで公開される場合、
UTXOセットに永久に存在する必要はありません。
Bitcoin Core 0.13.0では、ユーザーがベア・マルチシグアウトプットを含む未承認トランザクションを
拒否するように切り替えることができる起動オプション`-permitbaremultisig`が導入されました。

コンセンサスルールでは、アウトプットスクリプトを自由な形式にすることができますが、
Bitcoin Coreノードによってリレーされるのはわずかなパターンだけです。
これにより、検証コストやプロトコルアップグレードメカニズムなど、
ネットワーク内の多くの懸念を理解しやすくなります。
たとえば、opcodeを含むインプットスクリプトや、15個以上の署名を持つP2SHインプット、
witnessスタックに100を超える項目を持つP2WSHインプットは、非標準トランザクションになります。
（ポリシーの例やその動機については、この[ポリシーの概要][instagibbs policy zoo]をご覧ください。）

最後に、Bitcoinプロトコルは、活動中のソフトウェアプロジェクトであり、
将来の課題やユーザーのニーズに対応するために進化し続ける必要があります。
そのため、annexやTaprootのリーフバージョン、witnessバージョン、OP_SUCCESSおよび
多数のno-op opcodeなど、コンセンサスが有効であるにもかかわらず未使用のまま意図的に残された多数のアップグレードフックがあります。
ただし、攻撃が中央集権的な障害点の欠如によって妨げられるのと同様に、
ネットワーク全体のソフトウェアのアップグレードには、数万もの独立したノードオペレーターの協調した取り組みが必要です。
ノードは、その意味が定義されるまで、予約されたアップグレードフックを利用するトランザクションをリレーしません。
この抑制は、アプリケーションが矛盾する標準を独自に作成することを思いとどまらせることを目的としています。
これにより、あるアプリケーションの標準を、別のアプリケーションの標準を無効にすることなくコンセンサスに採用することは不可能になります。
また、コンセンサスの変更が発生した場合、すぐにアップグレードしないノード、
つまり新しいコンセンサスを知らないノードは、「騙されて」無効なトランザクションを自分のmempoolに受け入れることはできません。
積極的な抑制により、ノードの前方互換性が維持され、完全に同期したソフトウェアアップデートを必要とせずに、
ネットワークがコンセンサスルールを安全にアップグレードできるようになります。

ポリシーを使用して共有ネットワークリソースを保護することで、
ネットワークの特性を保護し、将来のプロトコル開発のための道を開いておくことができます。
一方、厳しく制限されたblockweightに対してネットワークを成長させる摩擦が、
ベストプラクティの採用、優れた技術設計、イノベーションの採用をどのように推進しているかが分かります。
来週の記事では、2ndレイヤープロトコルやスマートコントラクトシステムのインターフェースとしてのmempoolについて説明します。

[policy01]: /ja/newsletters/2023/05/17/#承認を待つ-1-なぜmempoolがあるのか
[unbounded]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/011865.html
[lopp storms]: https://blog.lopp.net/history-bitcoin-transaction-dust-spam-storms/
[ultraprune]: https://github.com/bitcoin/bitcoin/pull/1677
[pooled resource]: /ja/newsletters/2023/05/03/#bitcoin-core-25325
[instagibbs policy zoo]: https://gist.github.com/instagibbs/ee32be0126ec132213205b25b80fb3e8
